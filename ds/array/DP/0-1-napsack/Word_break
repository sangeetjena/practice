"""
Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.

Note that the same word in the dictionary may be reused multiple times in the segmentation.

 

Example 1:

Input: s = "leetcode", wordDict = ["leet","code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
Example 2:

Input: s = "applepenapple", wordDict = ["apple","pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
Note that you are allowed to reuse a dictionary word.
Example 3:

Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
Output: false

Note: this is a back tracking problem, similar to the o/1 knap sack. 

"""

class Solution:
    # helper method to find the word break in recurssion
    def __init__(self):
        self.memo = []
    def breakWord( self, index, word, dct):
        # base condition
        global memo
        if index >= len(word):
            return True
        # memoisation technique, retruning false just to break the call as already with the given index value we already did a parsing. so no need to do the parsing again. 
        if index in self.memo:
            return False
        self.memo.append(index)
        for i in range(index, len(word)+1):
            if word[index:i] in dct and self.breakWord(i,word,dct):
                return True
        return False
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        # this is a brack tracking problem where we will break word in each position and go in a recurssion call
        # when i find a valid word in the disctionalry, we will go and check if any word after the matching work is         # present in the sentence or not. when i find a valid word and reached to the end of the sentence then i will return true else false.
        return self.breakWord(0,s,wordDict)
        
        
